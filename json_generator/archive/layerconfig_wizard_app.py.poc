import os
import sys
import sqlite3

from PyQt5 import QtWidgets, QtCore, QtGui, uic

DB_FILENAME = "LayerConfig_v2.db"
UI_FILENAME = "LayerConfigNewLayerWizard.ui"


class LayerConfigNewLayerWizard(QtWidgets.QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)

        # Load UI
        base_dir = os.path.dirname(os.path.abspath(__file__))
        ui_path = os.path.join(base_dir, UI_FILENAME)
        if not os.path.exists(ui_path):
            raise FileNotFoundError(f"UI file not found: {ui_path}")

        uic.loadUi(ui_path, self)
        self.setWindowTitle("LayerConfig - New Layer From Mapfile")

        # DB connection
        db_path = os.path.join(base_dir, DB_FILENAME)
        if not os.path.exists(db_path):
            raise FileNotFoundError(f"Database not found: {db_path}")

        self.conn = sqlite3.connect(db_path)
        self.conn.row_factory = sqlite3.Row

        # Internal caches
        self._portal_id_by_index = []  # index -> PortalId
        self._tree_model = None
        self._mapfile_layers = {}      # layer_name -> mappyfile layer dict

        # Wire signals and then load data
        self._connect_signals()
        self._load_portals()

    # ------------------------------------------------------------------
    # Signal wiring
    # ------------------------------------------------------------------
    def _connect_signals(self):
        # Tab 1
        if hasattr(self, "btnBrowseMapFile"):
            self.btnBrowseMapFile.clicked.connect(self.on_browse_mapfile)

        if hasattr(self, "btnScanMapFile"):
            self.btnScanMapFile.clicked.connect(self.on_scan_mapfile)

        if hasattr(self, "cmbMapFileLayerNames"):
            self.cmbMapFileLayerNames.currentTextChanged.connect(
                self.on_map_layer_selected
            )

        # Tab 2
        if hasattr(self, "cmbPortalSelect"):
            self.cmbPortalSelect.currentIndexChanged.connect(
                self.on_portal_changed
            )

        if hasattr(self, "btnSavePortalToDatabase"):
            self.btnSavePortalToDatabase.clicked.connect(
                self.on_save_portal_to_database
            )

    # ------------------------------------------------------------------
    # Tab 1: Mapfile tab
    # ------------------------------------------------------------------
    def on_browse_mapfile(self):
        """Open a file dialog and set the mapfile path textbox."""
        if not hasattr(self, "txtMapFilePath"):
            return

        start_dir = (
            os.path.dirname(self.txtMapFilePath.text())
            if self.txtMapFilePath.text()
            else os.getcwd()
        )

        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self,
            "Select mapfile",
            start_dir,
            "MapServer mapfiles (*.map);;All files (*)",
        )
        if path:
            self.txtMapFilePath.setText(path)

    def on_scan_mapfile(self):
        """
        Parse the mapfile using mappyfile and populate cmbMapFileLayerNames
        with the LAYER NAME values.
        """
        if not hasattr(self, "txtMapFilePath") or not hasattr(self, "cmbMapFileLayerNames"):
            return

        map_path = self.txtMapFilePath.text().strip()
        if not map_path:
            QtWidgets.QMessageBox.warning(self, "No mapfile", "Please select a mapfile first.")
            return

        if not os.path.exists(map_path):
            QtWidgets.QMessageBox.critical(self, "Mapfile not found", f"File does not exist:\n{map_path}")
            return

        try:
            import mappyfile
        except ImportError:
            QtWidgets.QMessageBox.critical(
                self,
                "mappyfile not installed",
                "The mappyfile library is required to parse mapfiles.\n\n"
                "Install it in your environment, for example:\n"
                "    pip install mappyfile",
            )
            return

        try:
            with open(map_path, "r", encoding="utf-8") as f:
                ms_map = mappyfile.load(f)
        except Exception as exc:
            QtWidgets.QMessageBox.critical(
                self,
                "Error parsing mapfile",
                f"Failed to parse mapfile:\n{exc}",
            )
            return

        layers = ms_map.get("layers", [])
        self._mapfile_layers = {}
        self.cmbMapFileLayerNames.blockSignals(True)
        self.cmbMapFileLayerNames.clear()

        for lyr in layers:
            name = lyr.get("name")
            if not name:
                continue
            self._mapfile_layers[name] = lyr
            self.cmbMapFileLayerNames.addItem(name)

        self.cmbMapFileLayerNames.blockSignals(False)

        if self._mapfile_layers:
            # Select the first layer to trigger population
            self.cmbMapFileLayerNames.setCurrentIndex(0)
            self.on_map_layer_selected(self.cmbMapFileLayerNames.currentText())
        else:
            QtWidgets.QMessageBox.information(
                self,
                "No layers found",
                "No LAYER entries were found in this mapfile.",
            )

    def on_map_layer_selected(self, layer_name: str):
        """
        When the user selects a layer name in cmbMapFileLayerNames,
        populate derived keys, fields, and styles.
        """
        layer_name = (layer_name or "").strip()
        if not layer_name:
            return

        lyr = self._mapfile_layers.get(layer_name)
        if lyr is None:
            # Should not happen if scan logic is OK
            return

        # Show layer name
        if hasattr(self, "txtLayerName"):
            self.txtLayerName.setText(layer_name)

        # Derive keys/GridXType
        self._derive_keys_from_layer_name(layer_name)

        # Populate styles table from CLASS GROUP (excluding "labels")
        self._populate_styles_from_layer(lyr)

        # Populate fields (best effort from metadata)
        self._populate_fields_from_layer(lyr)

    def _derive_keys_from_layer_name(self, layer_name: str):
        """Derive WMS/VECTOR LayerKeys and GridXType from the MapServer layer name."""
        base = layer_name.upper()
        wms_key = f"{base}_WMS"
        vector_key = f"{base}_VECTOR"
        gridxtype = f"pms_{layer_name.lower()}grid"

        if hasattr(self, "txtWmsLayerKey"):
            self.txtWmsLayerKey.setText(wms_key)
        if hasattr(self, "txtVectorLayerKey"):
            self.txtVectorLayerKey.setText(vector_key)
        if hasattr(self, "txtGridXType") and not self.txtGridXType.text():
            self.txtGridXType.setText(gridxtype)

    def _populate_styles_from_layer(self, lyr: dict):
        """
        Fill tblStyles with unique CLASS GROUP names from this layer,
        excluding 'labels'.
        """
        if not hasattr(self, "tblStyles"):
            return

        tbl = self.tblStyles
        tbl.clearContents()
        tbl.setRowCount(0)

        classes = lyr.get("classes", [])
        groups = []
        seen = set()

        for cls in classes:
            group_name = cls.get("group")
            if not group_name:
                continue
            if group_name.lower() == "labels":
                continue
            if group_name in seen:
                continue
            seen.add(group_name)
            groups.append(group_name)

        for idx, group_name in enumerate(groups):
            tbl.insertRow(idx)
            group_item = QtWidgets.QTableWidgetItem(group_name)
            title_item = QtWidgets.QTableWidgetItem(group_name)
            tbl.setItem(idx, 0, group_item)
            tbl.setItem(idx, 1, title_item)

    def _populate_fields_from_layer(self, lyr: dict):
        """
        Try to infer field list and idProperty from layer METADATA:
        - Use gml_include_items or wfs_featureid if present.
        This is a best-effort; user can edit afterwards.
        """
        if not hasattr(self, "tblFields") or not hasattr(self, "cmbIdProperty"):
            return

        tbl = self.tblFields
        tbl.clearContents()
        tbl.setRowCount(0)
        self.cmbIdProperty.clear()

        metadata = lyr.get("metadata", {}) or {}

        # Try to get field names
        fields = []

        # Common patterns:
        # gml_include_items "field1,field2,field3"
        include_items = metadata.get("gml_include_items") or metadata.get("wfs_include_items")
        if include_items and include_items.lower() not in ("all", "*"):
            # mappyfile may store this already split, but assume string for now
            if isinstance(include_items, str):
                parts = [p.strip() for p in include_items.split(",") if p.strip()]
                fields.extend(parts)
            elif isinstance(include_items, (list, tuple)):
                fields.extend([str(p).strip() for p in include_items if str(p).strip()])

        # Fallback: if we got nothing, we just leave it empty and let the user define later
        fields = list(dict.fromkeys(fields))  # unique, preserve order

        # Try to find idProperty from metadata
        id_prop = metadata.get("wfs_featureid") or metadata.get("gml_featureid") or ""
        id_prop = id_prop.strip() if isinstance(id_prop, str) else ""

        for idx, fname in enumerate(fields):
            tbl.insertRow(idx)

            # Include checkbox
            include_item = QtWidgets.QTableWidgetItem()
            include_item.setFlags(include_item.flags() | QtCore.Qt.ItemIsUserCheckable)
            include_item.setCheckState(QtCore.Qt.Checked)
            tbl.setItem(idx, 0, include_item)

            # Field name
            name_item = QtWidgets.QTableWidgetItem(fname)
            tbl.setItem(idx, 1, name_item)

            # Type - unknown from mapfile, default to string
            type_item = QtWidgets.QTableWidgetItem("string")
            tbl.setItem(idx, 2, type_item)

            # Is idProperty
            id_item = QtWidgets.QTableWidgetItem()
            id_item.setFlags(id_item.flags() | QtCore.Qt.ItemIsUserCheckable)
            if id_prop and fname == id_prop:
                id_item.setCheckState(QtCore.Qt.Checked)
            else:
                id_item.setCheckState(QtCore.Qt.Unchecked)
            tbl.setItem(idx, 3, id_item)

            # Also add to idProperty combo
            self.cmbIdProperty.addItem(fname)

        # If we detected id_prop, set combo selection
        if id_prop and self.cmbIdProperty.count() > 0:
            idx = self.cmbIdProperty.findText(id_prop)
            if idx >= 0:
                self.cmbIdProperty.setCurrentIndex(idx)

    # ------------------------------------------------------------------
    # Tab 2: Portal tab: load portals, tree, available layers
    # ------------------------------------------------------------------
    def _load_portals(self):
        """Populate the portal combo from Portals table and select the first."""
        if not hasattr(self, "cmbPortalSelect"):
            return

        self.cmbPortalSelect.blockSignals(True)
        self.cmbPortalSelect.clear()
        self._portal_id_by_index = []

        cur = self.conn.execute(
            "SELECT PortalId, PortalKey, PortalTitle "
            "FROM Portals ORDER BY PortalId"
        )
        rows = cur.fetchall()
        for row in rows:
            label = f"{row['PortalKey']} ({row['PortalTitle']})"
            self.cmbPortalSelect.addItem(label)
            self._portal_id_by_index.append(row["PortalId"])

        self.cmbPortalSelect.blockSignals(False)

        if self._portal_id_by_index:
            self.cmbPortalSelect.setCurrentIndex(0)
            self.on_portal_changed(0)

    def on_portal_changed(self, index):
        """Called when the user switches portal in the combo."""
        if index < 0 or index >= len(self._portal_id_by_index):
            return

        portal_id = self._portal_id_by_index[index]
        self._load_portal_tree(portal_id)
        self._load_available_layers(portal_id)

    # ------------------------------------------------------------------
    # Portal tree
    # ------------------------------------------------------------------
    def _set_tree_model(self, model):
        """Assign the tree model and hook selection changed."""
        self._tree_model = model
        self.treePortalLayers.setModel(model)
        self.treePortalLayers.setHeaderHidden(False)
        self.treePortalLayers.header().setSectionResizeMode(
            0, QtWidgets.QHeaderView.Stretch
        )
        self.treePortalLayers.header().setSectionResizeMode(
            1, QtWidgets.QHeaderView.ResizeToContents
        )

        sel_model = self.treePortalLayers.selectionModel()
        if sel_model is not None:
            sel_model.selectionChanged.connect(self.on_tree_selection_changed)

    def _load_portal_tree(self, portal_id):
        """Load PortalTreeNodes into QTreeView for the given portal."""
        model = QtGui.QStandardItemModel()
        model.setHorizontalHeaderLabels(["Title", "LayerKey"])

        cur = self.conn.execute(
            "SELECT * FROM PortalTreeNodes "
            "WHERE PortalId = ? "
            "ORDER BY ParentNodeId, DisplayOrder, PortalTreeNodeId",
            (portal_id,),
        )
        rows = cur.fetchall()

        items_by_id = {}
        for row in rows:
            is_folder = bool(row["IsFolder"])
            if is_folder:
                title = row["FolderTitle"]
                layer_key = ""
            else:
                title = row["LayerKey"]
                layer_key = row["LayerKey"] or ""

            title_item = QtGui.QStandardItem(title if title else "")
            layer_item = QtGui.QStandardItem(layer_key)

            title_item.setData(row["PortalTreeNodeId"], QtCore.Qt.UserRole)
            title_item.setData(is_folder, QtCore.Qt.UserRole + 1)
            title_item.setData(row["LayerKey"], QtCore.Qt.UserRole + 2)

            items_by_id[row["PortalTreeNodeId"]] = (title_item, layer_item)

        root = model.invisibleRootItem()

        for row in rows:
            node_id = row["PortalTreeNodeId"]
            parent_id = row["ParentNodeId"]
            title_item, layer_item = items_by_id[node_id]

            if parent_id is None:
                root.appendRow([title_item, layer_item])
            else:
                parent_items = items_by_id.get(parent_id)
                if parent_items is None:
                    root.appendRow([title_item, layer_item])
                else:
                    parent_title_item = parent_items[0]
                    parent_title_item.appendRow([title_item, layer_item])

        self._set_tree_model(model)
        self.treePortalLayers.expandAll()
        self._clear_node_details()

    def on_tree_selection_changed(self, selected, _deselected):
        """Update node details panel when a node is selected."""
        indexes = selected.indexes()
        if not indexes:
            self._clear_node_details()
            return

        idx = indexes[0]
        item = self._tree_model.itemFromIndex(idx)
        if item is None:
            self._clear_node_details()
            return

        node_id = item.data(QtCore.Qt.UserRole)
        is_folder = bool(item.data(QtCore.Qt.UserRole + 1))

        if node_id is None:
            self._clear_node_details()
            return

        cur = self.conn.execute(
            "SELECT * FROM PortalTreeNodes WHERE PortalTreeNodeId = ?",
            (node_id,),
        )
        row = cur.fetchone()
        if row is None:
            self._clear_node_details()
            return

        if is_folder:
            self._populate_folder_details(row)
            self._populate_layer_details(None)
        else:
            self._populate_folder_details(None)
            self._populate_layer_details(row)

    def _clear_node_details(self):
        self._populate_folder_details(None)
        self._populate_layer_details(None)

    def _populate_folder_details(self, row):
        if not hasattr(self, "groupBox_folderDetails"):
            return

        if row is None or not bool(row["IsFolder"]):
            self.groupBox_folderDetails.setEnabled(False)
            if hasattr(self, "txtFolderTitle"):
                self.txtFolderTitle.clear()
            if hasattr(self, "chkFolderExpanded"):
                self.chkFolderExpanded.setChecked(False)
            if hasattr(self, "chkFolderChecked"):
                self.chkFolderChecked.setChecked(False)
            return

        self.groupBox_folderDetails.setEnabled(True)
        if hasattr(self, "txtFolderTitle"):
            self.txtFolderTitle.setText(row["FolderTitle"] or "")
        if hasattr(self, "chkFolderExpanded"):
            self.chkFolderExpanded.setChecked(bool(row["ExpandedDefault"]))
        if hasattr(self, "chkFolderChecked"):
            self.chkFolderChecked.setChecked(bool(row["CheckedDefault"]))

    def _populate_layer_details(self, row):
        if not hasattr(self, "groupBox_layerDetails"):
            return

        if row is None or bool(row["IsFolder"]):
            self.groupBox_layerDetails.setEnabled(False)
            if hasattr(self, "txtLayerKey"):
                self.txtLayerKey.clear()
            if hasattr(self, "txtLayerTitle"):
                self.txtLayerTitle.clear()
            if hasattr(self, "txtLayerGlyph"):
                self.txtLayerGlyph.clear()
            if hasattr(self, "txtLayerTooltip"):
                self.txtLayerTooltip.clear()
            return

        self.groupBox_layerDetails.setEnabled(True)

        layer_key = row["LayerKey"] or ""
        if hasattr(self, "txtLayerKey"):
            self.txtLayerKey.setText(layer_key)
        if hasattr(self, "txtLayerTitle"):
            self.txtLayerTitle.setText(layer_key)
        if hasattr(self, "txtLayerGlyph"):
            self.txtLayerGlyph.setText(row["Glyph"] or "")
        if hasattr(self, "txtLayerTooltip"):
            self.txtLayerTooltip.setPlainText(row["Tooltip"] or "")

    # ------------------------------------------------------------------
    # Available layers
    # ------------------------------------------------------------------
    def _load_available_layers(self, portal_id):
        """Populate listAvailableLayers with ServiceLayers not used in this portal's tree."""
        if not hasattr(self, "listAvailableLayers"):
            return

        self.listAvailableLayers.clear()

        cur = self.conn.execute(
            "SELECT LayerKey FROM PortalTreeNodes "
            "WHERE PortalId = ? AND IsFolder = 0 AND LayerKey IS NOT NULL",
            (portal_id,),
        )
        used_keys = {row["LayerKey"] for row in cur.fetchall()}

        cur = self.conn.execute(
            "SELECT ServiceLayerId, LayerKey, ServiceType "
            "FROM ServiceLayers "
            "ORDER BY LayerKey"
        )
        rows = cur.fetchall()

        for row in rows:
            if row["LayerKey"] in used_keys:
                continue
            label = f"{row['LayerKey']} ({row['ServiceType']})"
            item = QtWidgets.QListWidgetItem(label)
            item.setData(QtCore.Qt.UserRole, row["LayerKey"])
            item.setData(QtCore.Qt.UserRole + 1, row["ServiceLayerId"])
            self.listAvailableLayers.addItem(item)

    # ------------------------------------------------------------------
    # Saving: hook Tab1 into DB via the Save Portal button
    # ------------------------------------------------------------------
    def on_save_portal_to_database(self):
        """
        For now: ensure the new layer (Tab 1) is saved to the core tables.
        Portal tree saving comes later.
        """
        try:
            self._save_new_layer_from_tab1()
            self.conn.commit()
        except Exception as exc:
            self.conn.rollback()
            QtWidgets.QMessageBox.critical(
                self,
                "Error saving layer",
                f"Failed to save new layer:\n{exc}",
            )
            return

        # Refresh available layers for current portal
        idx = self.cmbPortalSelect.currentIndex() if hasattr(self, "cmbPortalSelect") else -1
        if 0 <= idx < len(self._portal_id_by_index):
            portal_id = self._portal_id_by_index[idx]
            self._load_available_layers(portal_id)

        QtWidgets.QMessageBox.information(
            self,
            "Layer saved",
            "New layer (if any) saved to database.",
        )

    def _save_new_layer_from_tab1(self):
        """
        Inspect Tab 1 widgets and, if they describe a new layer,
        insert into MapServerLayers, ServiceLayers, MapServerLayerFields, and MapServerLayerStyles.
        If the layer already exists (by BaseLayerKey or MapLayerName), do nothing.
        """
        if not (
            hasattr(self, "txtLayerName")
            and hasattr(self, "txtWmsLayerKey")
            and hasattr(self, "txtVectorLayerKey")
        ):
            return

        layer_name = self.txtLayerName.text().strip()
        wms_key = self.txtWmsLayerKey.text().strip()
        vector_key = self.txtVectorLayerKey.text().strip()

        if not layer_name or not wms_key or not vector_key:
            # Nothing to save
            return

        base_key = wms_key
        if base_key.upper().endswith("_WMS"):
            base_key = base_key[:-4]

        gridxtype = self.txtGridXType.text().strip() if hasattr(self, "txtGridXType") else ""
        if not gridxtype:
            gridxtype = f"pms_{layer_name.lower()}grid"

        geom_field = self.txtGeomFieldName.text().strip() if hasattr(self, "txtGeomFieldName") else "msGeometry"
        if not geom_field:
            geom_field = "msGeometry"

        label_class = self.txtLabelClassName.text().strip() if hasattr(self, "txtLabelClassName") else "labels"
        if not label_class:
            label_class = "labels"

        opacity = self.spinOpacity.value() if hasattr(self, "spinOpacity") else 0.75

        # Check if this MapServer layer already exists
        cur = self.conn.execute(
            "SELECT MapServerLayerId FROM MapServerLayers "
            "WHERE MapLayerName = ? OR BaseLayerKey = ?",
            (layer_name, base_key),
        )
        row = cur.fetchone()
        if row is not None:
            # Already exists, skip creating it
            return

        # Insert MapServerLayers
        cur = self.conn.execute(
            """
            INSERT INTO MapServerLayers
                (MapLayerName, BaseLayerKey, GridXType,
                 GeometryType, DefaultGeomFieldName,
                 DefaultLabelClassName, DefaultOpacity, Notes)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (
                layer_name,
                base_key,
                gridxtype,
                "LINESTRING",         # POC default
                geom_field,
                label_class,
                opacity,
                None,
            ),
        )
        mapserver_layer_id = cur.lastrowid

        # Determine idProperty from combo or table
        id_property_name = ""
        if hasattr(self, "cmbIdProperty") and self.cmbIdProperty.currentText():
            id_property_name = self.cmbIdProperty.currentText().strip()

        # Insert ServiceLayers: WMS and WFS (vector)
        for service_type, layer_key in (("WMS", wms_key), ("WFS", vector_key)):
            self.conn.execute(
                """
                INSERT INTO ServiceLayers
                    (MapServerLayerId, ServiceType, LayerKey,
                     FeatureType, IdPropertyName,
                     GeomFieldName, LabelClassName,
                     Opacity, OpenLayersJson, ServerOptionsJson)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    mapserver_layer_id,
                    service_type,
                    layer_key,
                    layer_name,
                    id_property_name or None,
                    geom_field,
                    label_class,
                    opacity,
                    '{"projection":"EPSG:2157"}',
                    None,
                ),
            )

        # Fields from tblFields
        if hasattr(self, "tblFields"):
            self._save_fields_for_layer(mapserver_layer_id, id_property_name)

        # Styles from tblStyles
        if hasattr(self, "tblStyles"):
            self._save_styles_for_layer(mapserver_layer_id)

    def _save_fields_for_layer(self, mapserver_layer_id: int, id_property_name: str):
        tbl = self.tblFields
        row_count = tbl.rowCount()
        for row_idx in range(row_count):
            include_item = tbl.item(row_idx, 0)
            include_csv = 1 if include_item and include_item.checkState() == QtCore.Qt.Checked else 0

            name_item = tbl.item(row_idx, 1)
            field_name = name_item.text().strip() if name_item else ""
            if not field_name:
                continue

            type_item = tbl.item(row_idx, 2)
            field_type = type_item.text().strip() if type_item else "string"

            id_item = tbl.item(row_idx, 3)
            is_id_flag = 0
            if id_item and id_item.checkState() == QtCore.Qt.Checked:
                is_id_flag = 1
            elif id_property_name and field_name == id_property_name:
                is_id_flag = 1

            display_order = row_idx + 1

            self.conn.execute(
                """
                INSERT INTO MapServerLayerFields
                    (MapServerLayerId, FieldName, FieldType,
                     IncludeInPropertyCsv, IsIdProperty, DisplayOrder)
                VALUES (?, ?, ?, ?, ?, ?)
                """,
                (
                    mapserver_layer_id,
                    field_name,
                    field_type,
                    include_csv,
                    is_id_flag,
                    display_order,
                ),
            )

    def _save_styles_for_layer(self, mapserver_layer_id: int):
        tbl = self.tblStyles
        row_count = tbl.rowCount()
        for row_idx in range(row_count):
            group_item = tbl.item(row_idx, 0)
            title_item = tbl.item(row_idx, 1)

            group_name = group_item.text().strip() if group_item else ""
            style_title = title_item.text().strip() if title_item else ""

            if not group_name:
                continue
            if not style_title:
                style_title = group_name

            display_order = row_idx + 1

            self.conn.execute(
                """
                INSERT INTO MapServerLayerStyles
                    (MapServerLayerId, GroupName, StyleTitle, DisplayOrder)
                VALUES (?, ?, ?, ?)
                """,
                (
                    mapserver_layer_id,
                    group_name,
                    style_title,
                    display_order,
                ),
            )


def main():
    app = QtWidgets.QApplication(sys.argv)
    window = LayerConfigNewLayerWizard()
    window.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
